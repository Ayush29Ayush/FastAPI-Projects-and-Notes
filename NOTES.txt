Course reference => https://www.udemy.com/course/fastapi-the-complete-course/

#! Create a Virtual Environment
1. python3 -m venv venv
2. venv\Scripts\activate
3. Install all requirements => pip install fastapi, pip install "uvicorn[standard]", pip install "fastapi[standard]"
4. pip freeze > requirements.txt
5. pip install -r requirements.txt
4. pip list

#? Project - 1

#! Create First FastAPI endpoint
1. Create a python file named books.py inside a folder named "Project-1"
"
from fastapi import Body, FastAPI

app = FastAPI()

@app.get("/")
async def first_api():
    return {"message": "Hello World"}
"
2. Run uvicorn Project-1.books:app --reload
3. More detailed way to run the server => uvicorn Project-1.books:app --reload --host 127.0.0.1 --port 8000

#* Since you have installed fastapi[standard] package, you can also use " fastapi dev .\Project-1\books.py" for running the server using fastapi-cli
"
(venv) PS D:\FastAPI - The Complete Course 2024 (Beginner + Advanced)> fastapi dev .\Project-1\books.py
INFO     Using path Project-1\books.py
INFO     Resolved absolute path D:\FastAPI - The Complete Course 2024 (Beginner + Advanced)\Project-1\books.py
INFO     Searching for package file structure from directories with __init__.py files
INFO     Importing from D:\FastAPI - The Complete Course 2024 (Beginner + Advanced)\Project-1

 â•­â”€ Python module file â”€â•®
 â”‚                      â”‚
 â”‚  ðŸ books.py         â”‚
 â”‚                      â”‚
 â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

INFO     Importing module books
INFO     Found importable FastAPI app

 â•­â”€ Importable FastAPI app â”€â•®
 â”‚                          â”‚
 â”‚  from books import app   â”‚
 â”‚                          â”‚
 â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

INFO     Using import string books:app

 â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ FastAPI CLI - Development mode â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
 â”‚                                                     â”‚
 â”‚  Serving at: http://127.0.0.1:8000                  â”‚
 â”‚                                                     â”‚
 â”‚  API docs: http://127.0.0.1:8000/docs               â”‚
 â”‚                                                     â”‚
 â”‚  Running in development mode, for production use:   â”‚
 â”‚                                                     â”‚
 â”‚  fastapi run                                        â”‚
 â”‚                                                     â”‚
 â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

INFO:     Will watch for changes in these directories: ['D:\\FastAPI - The Complete Course 2024 (Beginner + Advanced)']
INFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO:     Started reloader process [15760] using WatchFiles
INFO:     Started server process [18512]
INFO:     Waiting for application startup.
INFO:     Application startup complete.
"

* For Development Mode use: fastapi dev
* For Production Mode use: fastapi run

#! Enhance GET request
"
from fastapi import Body, FastAPI

app = FastAPI()

@app.get("/")
async def first_api():
    return {"message": "Hello World"}


BOOKS = [
    {"title": "Title One", "author": "Author One", "category": "science"},
    {"title": "Title Two", "author": "Author Two", "category": "science"},
    {"title": "Title Three", "author": "Author Three", "category": "history"},
    {"title": "Title Four", "author": "Author Four", "category": "math"},
    {"title": "Title Five", "author": "Author Five", "category": "math"},
    {"title": "Title Six", "author": "Author Two", "category": "math"},
]


@app.get("/books")
async def read_all_books():
    return BOOKS
"

#! Path Parameters - Making URL dynamic
1. Path Parameters are request parameters that have been attached to the URL
2. Path Parameters are usually defined as a way to find information based on location
3. Order of typing and placing the api in the code file matters in Path Parameters
"
from fastapi import Body, FastAPI

app = FastAPI()

@app.get("/")
async def first_api():
    return {"message": "Hello World"}

@app.get("/test/{dynamic_param}")
async def second_api(dynamic_param):
    return {"message": dynamic_param}


BOOKS = [
    {"title": "Title One", "author": "Author One", "category": "science"},
    {"title": "Title Two", "author": "Author Two", "category": "science"},
    {"title": "Title Three", "author": "Author Three", "category": "history"},
    {"title": "Title Four", "author": "Author Four", "category": "math"},
    {"title": "Title Five", "author": "Author Five", "category": "math"},
    {"title": "Title Six", "author": "Author Two", "category": "math"},
]


@app.get("/books")
async def read_all_books():
    return BOOKS

@app.get("/books/mybook")
async def read_my_book():
    return {"title": "My favorite book"}


@app.get("/books/{book_title}")
async def read_book(book_title: str):
    for book in BOOKS:
        if book.get('title').casefold() == book_title.casefold():
            return book
"

#! Query Parameters - Making URL dynamic
1. Query Parameters are request parameters that have been attached after a â€œ?â€
2. Query Parameters have name=value pairs
3. Example => 127.0.0.1:8000/books/?category=math/
"
# http://127.0.0.1:8000/books/?category=math
@app.get("/books/")
async def read_category_by_query(category: str):
    books_to_return = []
    for book in BOOKS:
        if book.get('category').casefold() == category.casefold():
            books_to_return.append(book)
    return books_to_return


# http://127.0.0.1:8000/books/author%20one/?category=science
@app.get("/books/{book_author}/")
async def read_author_category_by_query(book_author: str, category: str):
    books_to_return = []
    for book in BOOKS:
        if book.get('author').casefold() == book_author.casefold() and book.get('category').casefold() == category.casefold():
            books_to_return.append(book)

    return books_to_return
"

#! POST Request
"
@app.post("/books/create_book")
async def create_book(new_book=Body()):
    print(new_book)
    BOOKS.append(new_book)
    print(BOOKS)
"

#! PUT Request
"
@app.put("/books/update_book")
async def update_book(updated_book=Body()):
    for i in range(len(BOOKS)):
        if BOOKS[i].get('title').casefold() == updated_book.get('title').casefold():
            BOOKS[i] = updated_book
"

#! DELETE Request
"
@app.delete("/books/delete_book/{book_title}")
async def delete_book(book_title: str):
    for i in range(len(BOOKS)):
        if BOOKS[i].get('title').casefold() == book_title.casefold():
            BOOKS.pop(i)
            break
"

#TODO => Assignment
1. Create a new API Endpoint that can fetch all books from a specific author using either Path Parameters or Query Parameters.
"
'''
Get all books from a specific author using path or query parameters
'''

# http://127.0.0.1:8000/test/assignment/?query_param_author=author%20two
@app.get("/test/assignment/")
async def read_all_books_by_author_query(query_param_author: str):
    books_to_return = []
    for book in BOOKS:
        if book.get('author').casefold() == query_param_author.casefold():
            books_to_return.append(book)

    return books_to_return

# http://127.0.0.1:8000/test/assignment/author%20two/
@app.get("/test/assignment/{path_param_author}/")
async def read_all_books_by_author_path(path_param_author: str):
    books_to_return = []
    for book in BOOKS:
        if book.get('author').casefold() == path_param_author.casefold():
            books_to_return.append(book)

    return books_to_return
"

-----------------------------------------------------------------------------------------------

#? Project 2
â€¢ Project two will still be focused on creating Book API Endpoints
â€¢ Continued Education includes: 
â€¢ GET, POST, PUT, DELETE Request Methods
â€¢ New Information will include: 
â€¢ Data Validation, Exception Handling, Status Codes, Swagger Configuration, Python Request Objects

#? Pydantic v1 vs Pydantic v2
FastAPI is now compatible with both Pydantic v1 and Pydantic v2.
Based on how new the version of FastAPI you are using, there could be small method name changes.

The three biggest are:
â€¢ .dict() function is now renamed to .model_dump()
â€¢ schema_extra function within a Config class is now renamed to json_schema_extra
â€¢ Optional variables need a =None example: id: Optional[int] = None

#! Setup Project - 2
1. Create a directory named "Project-2" and create a new python file named "books2.py"
2. Run the server using "fastapi dev .\Project-2\books2.py"
"
from fastapi import FastAPI

app = FastAPI()


class Book:
    id: int
    title: str
    author: str
    description: str
    rating: int

    def __init__(self, id, title, author, description, rating):
        self.id = id
        self.title = title
        self.author = author
        self.description = description
        self.rating = rating


BOOKS = [
    Book(1, 'Computer Science Pro', 'codingwithroby', 'A very nice book!', 5),
    Book(2, 'Be Fast with FastAPI', 'codingwithroby', 'A great book!', 5),
    Book(3, 'Master Endpoints', 'codingwithroby', 'A awesome book!', 5),
    Book(4, 'HP1', 'Author 1', 'Book Description', 2),
    Book(5, 'HP2', 'Author 2', 'Book Description', 3),
    Book(6, 'HP3', 'Author 3', 'Book Description', 1)
]


@app.get("/books")
async def read_all_books():
    return BOOKS
"

#! Post request before Validation
This is a basic post request that will create a new book but is not robust and will not validate the data.
"
@app.get("/create-book")
async def create_book(book_request=Body()):
    BOOKS.append(book_request)
"

#! Pydantics and Data Validation
â€¢ Python library that is used for data modeling, data parsing and has 
efficient error handling.
â€¢ Pydantics is commonly used as a resource for data validation and how to 
handle data coming to our FastAPI application.
â€¢ ** operator will pass the key/value from the request body to the Model class constructor.
"
from fastapi import Body, FastAPI
from pydantic import BaseModel

app = FastAPI()

class Book:
    id: int
    title: str
    author: str
    description: str
    rating: int

    def __init__(self, id, title, author, description, rating):
        self.id = id
        self.title = title
        self.author = author
        self.description = description
        self.rating = rating

class BookRequest(BaseModel):
    id: int
    title: str
    author: str
    description: str
    rating: int

BOOKS = [
    Book(1, 'Computer Science Pro', 'codingwithroby', 'A very nice book!', 5),
    Book(2, 'Be Fast with FastAPI', 'codingwithroby', 'A great book!', 5),
    Book(3, 'Master Endpoints', 'codingwithroby', 'A awesome book!', 5),
    Book(4, 'HP1', 'Author 1', 'Book Description', 2),
    Book(5, 'HP2', 'Author 2', 'Book Description', 3),
    Book(6, 'HP3', 'Author 3', 'Book Description', 1)
]


@app.get("/books")
async def read_all_books():
    return BOOKS

# @app.get("/create-book")
# async def create_book(book_request=Body()):
#     BOOKS.append(book_request)

@app.post("/create-book")
async def create_book(book_request: BookRequest):
    print(type(book_request)) #! <class 'books2.BookRequest'>
    print(book_request,"\n") #! id=0 title='string' author='string' description='string' rating=0 
    new_book = Book(**book_request.model_dump()) #! Converts the request to Book object
    print(type(new_book)) #! <class 'books2.Book'>
    print(new_book) #! <books2.Book object at 0x000001BE8A762840>
    BOOKS.append(new_book)
"

#! Data Validation with Pydantic -> Field Validation and id increments
"
from typing import Optional
from fastapi import Body, FastAPI
from pydantic import BaseModel, Field

app = FastAPI()


class Book:
    id: int
    title: str
    author: str
    description: str
    rating: int

    def __init__(self, id, title, author, description, rating):
        self.id = id
        self.title = title
        self.author = author
        self.description = description
        self.rating = rating

class BookRequest(BaseModel):
    id: Optional[int] = Field(description='ID is not needed on create', default=None)
    title: str = Field(min_length=3)
    author: str = Field(min_length=1)
    description: str = Field(min_length=1, max_length=100)
    rating: int = Field(gt=0, lt=6)

BOOKS = [
    Book(1, 'Computer Science Pro', 'codingwithroby', 'A very nice book!', 5),
    Book(2, 'Be Fast with FastAPI', 'codingwithroby', 'A great book!', 5),
    Book(3, 'Master Endpoints', 'codingwithroby', 'A awesome book!', 5),
    Book(4, 'HP1', 'Author 1', 'Book Description', 2),
    Book(5, 'HP2', 'Author 2', 'Book Description', 3),
    Book(6, 'HP3', 'Author 3', 'Book Description', 1)
]


@app.get("/books")
async def read_all_books():
    return BOOKS


@app.post("/create-book")
async def create_book(book_request: BookRequest): 
    new_book = Book(**book_request.model_dump()) #! Converts the request to Book object
    BOOKS.append(find_book_id(new_book))
    
def find_book_id(book: Book):
    #! If there are no books, the ID will be 1 and if there are few books present from before, the ID will be the last ID + 1
    book.id = 1 if len(BOOKS) == 0 else BOOKS[-1].id + 1
    
    # if len(BOOKS) > 0:
    #     book.id = BOOKS[-1].id + 1
    # else:
    #     book.id = 1
        
    return book
"

#! Pydantic Configuration
"
class BookRequest(BaseModel):
    id: Optional[int] = Field(description='ID is not needed on create', default=None)
    title: str = Field(min_length=3)
    author: str = Field(min_length=1)
    description: str = Field(min_length=1, max_length=100)
    rating: int = Field(gt=0, lt=6)
    
    model_config = {
        "json_schema_extra": {
            "example": {
                "title": "A new book",
                "author": "codingwithroby",
                "description": "A new description of a book",
                "rating": 5
            }
        }
    }
"

#! Fetch a single book
"
@app.get("/books/{book_id}")
async def read_book(book_id: int):
    for book in BOOKS:
        if book.id == book_id:
            return book
"

#! Fetch books by rating
"
@app.get("/books/")
async def read_book_by_rating(book_rating: int):
    books_to_return = []
    for book in BOOKS:
        if book.rating == book_rating:
            books_to_return.append(book)
            
    return books_to_return
"

#! Update Book with PUT Request
"
@app.put("/books/update_book")
async def update_book(book: BookRequest):
    book_changed = False
    for i in range(len(BOOKS)):
        if BOOKS[i].id == book.id:
            BOOKS[i] = book  
"

#! Delete Book with DELETE Request
"
@app.delete("/books/{book_id}")
async def delete_book(book_id: int):
    for i in range(len(BOOKS)):
        if BOOKS[i].id == book_id:
            BOOKS.pop(i)
            break
"

#? Assignment
Add a new field to Book and BookRequest called published_date: int (for example, published_date: int = 2012). So, this book as published on the year of 2012.
Enhance each Book to now have a published_date
Then create a new GET Request method to filter by published_date

"
from typing import Optional
from fastapi import Body, FastAPI
from pydantic import BaseModel, Field

app = FastAPI()

class Book:
    id: int
    title: str
    author: str
    description: str
    rating: int
    published_date: int

    def __init__(self, id, title, author, description, rating, published_date):
        self.id = id
        self.title = title
        self.author = author
        self.description = description
        self.rating = rating
        self.published_date = published_date

class BookRequest(BaseModel):
    id: Optional[int] = Field(description='ID is not needed on create', default=None)
    title: str = Field(min_length=3)
    author: str = Field(min_length=1)
    description: str = Field(min_length=1, max_length=100)
    rating: int = Field(gt=0, lt=6)
    published_date: int = Field(gt=2000, lt=2050)
    
    model_config = {
        "json_schema_extra": {
            "example": {
                "title": "A new book",
                "author": "codingwithroby",
                "description": "A new description of a book",
                "rating": 5,
                "published_date": 2024
            }
        }
    }

BOOKS = [
    Book(1, 'Computer Science Pro', 'codingwithroby', 'A very nice book!', 5, 2022),
    Book(2, 'Be Fast with FastAPI', 'codingwithroby', 'A great book!', 5, 2021),
    Book(3, 'Master Endpoints', 'codingwithroby', 'A awesome book!', 5, 2020),
    Book(4, 'HP1', 'Author 1', 'Book Description', 2, 2023),
    Book(5, 'HP2', 'Author 2', 'Book Description', 3, 2022),
    Book(6, 'HP3', 'Author 3', 'Book Description', 1, 2024)
]

@app.get("/books")
async def read_all_books():
    return BOOKS

@app.get("/books/{book_id}")
async def read_book(book_id: int):
    for book in BOOKS:
        if book.id == book_id:
            return book

@app.get("/books/")
async def read_book_by_rating(book_rating: int):
    books_to_return = []
    for book in BOOKS:
        if book.rating == book_rating:
            books_to_return.append(book)
            
    return books_to_return

@app.get("/books/publish/")
async def read_books_by_publish_date(published_date: int):
    books_to_return = []
    for book in BOOKS:
        if book.published_date == published_date:
            books_to_return.append(book)
    return books_to_return

@app.post("/create-book")
async def create_book(book_request: BookRequest): 
    new_book = Book(**book_request.model_dump()) #! Converts the request to Book object
    BOOKS.append(find_book_id(new_book))
    
def find_book_id(book: Book):
    #! If there are no books, the ID will be 1 and if there are few books present from before, the ID will be the last ID + 1
    book.id = 1 if len(BOOKS) == 0 else BOOKS[-1].id + 1        
    return book

@app.put("/books/update_book")
async def update_book(book: BookRequest):
    book_changed = False
    for i in range(len(BOOKS)):
        if BOOKS[i].id == book.id:
            BOOKS[i] = book  
            
@app.delete("/books/{book_id}")
async def delete_book(book_id: int):
    for i in range(len(BOOKS)):
        if BOOKS[i].id == book_id:
            BOOKS.pop(i)
            break
"

#! Data Validation Path Parameters
* used to validate and add constraints to the path parameter
* Example => Add Path(gt=0) to ID parameter in read_book() method

#! Data Validation Query Parameters
* used to validate and add constraints to the query parameter
* Example => Add Query(gt=0) to Rating parameter in read_book_by_rating() method

#! Status Codes
â€¢ An HTTP Status Code is used to help the Client (the user or system submitting data to the server) to understand what happened on the server side application.
â€¢ Status Codes are international standards on how a Client/Server should handle the result of a request.
â€¢ It allows everyone who sends a request to know if their submission was successful or not.

1xx => Success: Request Successfully complete
2xx => Information Response: Request Processing.
3xx => Redirection: Further action must be complete
4xx => Client Errors: An error was caused by the client.
5xx => Server Errors: An error occurred on the server.

#! HTTP Exceptions and status codes
"
from typing import Optional
from fastapi import Body, FastAPI, Path, Query, HTTPException
from pydantic import BaseModel, Field
from starlette import status

app = FastAPI()


class Book:
    id: int
    title: str
    author: str
    description: str
    rating: int
    published_date: int

    def __init__(self, id, title, author, description, rating, published_date):
        self.id = id
        self.title = title
        self.author = author
        self.description = description
        self.rating = rating
        self.published_date = published_date

class BookRequest(BaseModel):
    id: Optional[int] = Field(description='ID is not needed on create', default=None)
    title: str = Field(min_length=3)
    author: str = Field(min_length=1)
    description: str = Field(min_length=1, max_length=100)
    rating: int = Field(gt=0, lt=6)
    published_date: int = Field(gt=2000, lt=2050)
    
    model_config = {
        "json_schema_extra": {
            "example": {
                "title": "A new book",
                "author": "codingwithroby",
                "description": "A new description of a book",
                "rating": 5,
                "published_date": 2024
            }
        }
    }

BOOKS = [
    Book(1, 'Computer Science Pro', 'codingwithroby', 'A very nice book!', 5, 2022),
    Book(2, 'Be Fast with FastAPI', 'codingwithroby', 'A great book!', 5, 2021),
    Book(3, 'Master Endpoints', 'codingwithroby', 'A awesome book!', 5, 2020),
    Book(4, 'HP1', 'Author 1', 'Book Description', 2, 2023),
    Book(5, 'HP2', 'Author 2', 'Book Description', 3, 2022),
    Book(6, 'HP3', 'Author 3', 'Book Description', 1, 2024)
]


@app.get("/books", status_code=status.HTTP_200_OK)
async def read_all_books():
    return BOOKS


@app.get("/books/{book_id}", status_code=status.HTTP_200_OK)
async def read_book(book_id: int = Path(gt=0)):
    for book in BOOKS:
        if book.id == book_id:
            return book
    raise HTTPException(status_code=404, detail='Item not found')


@app.get("/books/", status_code=status.HTTP_200_OK)
async def read_book_by_rating(book_rating: int = Query(gt=0, lt=6)):
    books_to_return = []
    for book in BOOKS:
        if book.rating == book_rating:
            books_to_return.append(book)
    return books_to_return


@app.get("/books/publish/", status_code=status.HTTP_200_OK)
async def read_books_by_publish_date(published_date: int = Query(gt=1999, lt=2031)):
    books_to_return = []
    for book in BOOKS:
        if book.published_date == published_date:
            books_to_return.append(book)
    return books_to_return


@app.post("/create-book", status_code=status.HTTP_201_CREATED)
async def create_book(book_request: BookRequest): 
    new_book = Book(**book_request.model_dump()) #! Converts the request to Book object
    BOOKS.append(find_book_id(new_book))
    
def find_book_id(book: Book):
    #! If there are no books, the ID will be 1 and if there are few books present from before, the ID will be the last ID + 1
    book.id = 1 if len(BOOKS) == 0 else BOOKS[-1].id + 1        
    return book


@app.put("/books/update_book", status_code=status.HTTP_204_NO_CONTENT)
async def update_book(book: BookRequest):
    book_changed = False
    for i in range(len(BOOKS)):
        if BOOKS[i].id == book.id:
            BOOKS[i] = book
            book_changed = True
    if not book_changed:
        raise HTTPException(status_code=404, detail='Item not found')
            

@app.delete("/books/{book_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_book(book_id: int = Path(gt=0)):
    book_changed = False
    for i in range(len(BOOKS)):
        if BOOKS[i].id == book_id:
            BOOKS.pop(i)
            book_changed = True
            break
    if not book_changed:
        raise HTTPException(status_code=404, detail='Item not found')
"

-----------------------------------------------------------

#? Project - 3
â€¢ Project three we will be switching our focus to TODOS instead of BOOKS
â€¢ New Information will include: 
â€¢ Full SQL Database
â€¢ Authentication
â€¢ Authorization
â€¢ Hashing Passwords

#! MySQL Database Intro
â€¢ Organized collection of structured information of data, which is stored in a computer system.
â€¢ The data can be easily accessed
â€¢ The data can be modified
â€¢ The data can be controlled and organized
â€¢ Many databases use a structured query language (SQL) to modify and write data

â€¢ A database is a collection of data
â€¢ Since data, on its own, is just data. A database allows management of this data
â€¢ Databases are organized in how data can be retrieved, stored and modified
â€¢ There are many types of Database Management Systems -> MySQL, PostgreSQL, SQLite, MongoDB

#! Database Connection with ORM SQLAlchemy
* ORM is an object-relational mapper
* ORM is a library that allows us to interact with our database and perform CRUD and other database operations.
* Now run => pip install sqlalchemy 
* Now create a TodoApp directory and then a py file named database.py
"
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from sqlalchemy.ext.declarative import declarative_base

SQLALCHEMY_DATABASE_URL = 'sqlite:///./todosapp.db'

engine = create_engine(SQLALCHEMY_DATABASE_URL, connect_args={'check_same_thread': False})

SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

Base = declarative_base()
"

#! Database Tables (Models)
1. Inside the TodoApp directory, create a models.py file 
2. Since this is also a ORM based application, we have models similar to what we have in django
"
from database import Base
from sqlalchemy import Column, Integer, String, Boolean

class Todos(Base):
    __tablename__ = 'todos'

    id = Column(Integer, primary_key=True, index=True)
    title = Column(String)
    description = Column(String)
    priority = Column(Integer)
    complete = Column(Boolean, default=False)
"

#! Main (Create Database Connection for API)
1. Create a main.py file
"
from fastapi import FastAPI
import models
from database import engine

app = FastAPI()

models.Base.metadata.create_all(bind=engine)
"
2. Now run => fastapi dev .\Project-3\TodoApp\main.py
3. Your db will be created automatically