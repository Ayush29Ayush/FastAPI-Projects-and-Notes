Course reference => https://www.udemy.com/course/fastapi-the-complete-course/

#! Create a Virtual Environment
1. python3 -m venv venv
2. venv\Scripts\activate
3. Install all requirements => pip install fastapi, pip install "uvicorn[standard]", pip install "fastapi[standard]"
4. pip freeze > requirements.txt
5. pip install -r requirements.txt
4. pip list

#? Project - 1

#! Create First FastAPI endpoint
1. Create a python file named books.py inside a folder named "Project-1"
"
from fastapi import Body, FastAPI

app = FastAPI()

@app.get("/")
async def first_api():
    return {"message": "Hello World"}
"
2. Run uvicorn Project-1.books:app --reload
3. More detailed way to run the server => uvicorn Project-1.books:app --reload --host 127.0.0.1 --port 8000

#* Since you have installed fastapi[standard] package, you can also use " fastapi dev .\Project-1\books.py" for running the server using fastapi-cli
"
(venv) PS D:\FastAPI - The Complete Course 2024 (Beginner + Advanced)> fastapi dev .\Project-1\books.py
INFO     Using path Project-1\books.py
INFO     Resolved absolute path D:\FastAPI - The Complete Course 2024 (Beginner + Advanced)\Project-1\books.py
INFO     Searching for package file structure from directories with __init__.py files
INFO     Importing from D:\FastAPI - The Complete Course 2024 (Beginner + Advanced)\Project-1

 ╭─ Python module file ─╮
 │                      │
 │  🐍 books.py         │
 │                      │
 ╰──────────────────────╯

INFO     Importing module books
INFO     Found importable FastAPI app

 ╭─ Importable FastAPI app ─╮
 │                          │
 │  from books import app   │
 │                          │
 ╰──────────────────────────╯

INFO     Using import string books:app

 ╭────────── FastAPI CLI - Development mode ───────────╮
 │                                                     │
 │  Serving at: http://127.0.0.1:8000                  │
 │                                                     │
 │  API docs: http://127.0.0.1:8000/docs               │
 │                                                     │
 │  Running in development mode, for production use:   │
 │                                                     │
 │  fastapi run                                        │
 │                                                     │
 ╰─────────────────────────────────────────────────────╯

INFO:     Will watch for changes in these directories: ['D:\\FastAPI - The Complete Course 2024 (Beginner + Advanced)']
INFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO:     Started reloader process [15760] using WatchFiles
INFO:     Started server process [18512]
INFO:     Waiting for application startup.
INFO:     Application startup complete.
"

* For Development Mode use: fastapi dev
* For Production Mode use: fastapi run

#! Enhance GET request
"
from fastapi import Body, FastAPI

app = FastAPI()

@app.get("/")
async def first_api():
    return {"message": "Hello World"}


BOOKS = [
    {"title": "Title One", "author": "Author One", "category": "science"},
    {"title": "Title Two", "author": "Author Two", "category": "science"},
    {"title": "Title Three", "author": "Author Three", "category": "history"},
    {"title": "Title Four", "author": "Author Four", "category": "math"},
    {"title": "Title Five", "author": "Author Five", "category": "math"},
    {"title": "Title Six", "author": "Author Two", "category": "math"},
]


@app.get("/books")
async def read_all_books():
    return BOOKS
"

#! Path Parameters - Making URL dynamic
1. Path Parameters are request parameters that have been attached to the URL
2. Path Parameters are usually defined as a way to find information based on location
3. Order of typing and placing the api in the code file matters in Path Parameters
"
from fastapi import Body, FastAPI

app = FastAPI()

@app.get("/")
async def first_api():
    return {"message": "Hello World"}

@app.get("/test/{dynamic_param}")
async def second_api(dynamic_param):
    return {"message": dynamic_param}


BOOKS = [
    {"title": "Title One", "author": "Author One", "category": "science"},
    {"title": "Title Two", "author": "Author Two", "category": "science"},
    {"title": "Title Three", "author": "Author Three", "category": "history"},
    {"title": "Title Four", "author": "Author Four", "category": "math"},
    {"title": "Title Five", "author": "Author Five", "category": "math"},
    {"title": "Title Six", "author": "Author Two", "category": "math"},
]


@app.get("/books")
async def read_all_books():
    return BOOKS

@app.get("/books/mybook")
async def read_my_book():
    return {"title": "My favorite book"}


@app.get("/books/{book_title}")
async def read_book(book_title: str):
    for book in BOOKS:
        if book.get('title').casefold() == book_title.casefold():
            return book
"

#! Query Parameters - Making URL dynamic
1. Query Parameters are request parameters that have been attached after a “?”
2. Query Parameters have name=value pairs
3. Example => 127.0.0.1:8000/books/?category=math/
"
# http://127.0.0.1:8000/books/?category=math
@app.get("/books/")
async def read_category_by_query(category: str):
    books_to_return = []
    for book in BOOKS:
        if book.get('category').casefold() == category.casefold():
            books_to_return.append(book)
    return books_to_return


# http://127.0.0.1:8000/books/author%20one/?category=science
@app.get("/books/{book_author}/")
async def read_author_category_by_query(book_author: str, category: str):
    books_to_return = []
    for book in BOOKS:
        if book.get('author').casefold() == book_author.casefold() and book.get('category').casefold() == category.casefold():
            books_to_return.append(book)

    return books_to_return
"

#! POST Request
"
@app.post("/books/create_book")
async def create_book(new_book=Body()):
    print(new_book)
    BOOKS.append(new_book)
    print(BOOKS)
"

#! PUT Request
"
@app.put("/books/update_book")
async def update_book(updated_book=Body()):
    for i in range(len(BOOKS)):
        if BOOKS[i].get('title').casefold() == updated_book.get('title').casefold():
            BOOKS[i] = updated_book
"

#! DELETE Request
"
@app.delete("/books/delete_book/{book_title}")
async def delete_book(book_title: str):
    for i in range(len(BOOKS)):
        if BOOKS[i].get('title').casefold() == book_title.casefold():
            BOOKS.pop(i)
            break
"

#TODO => Assignment
1. Create a new API Endpoint that can fetch all books from a specific author using either Path Parameters or Query Parameters.
"
'''
Get all books from a specific author using path or query parameters
'''

# http://127.0.0.1:8000/test/assignment/?query_param_author=author%20two
@app.get("/test/assignment/")
async def read_all_books_by_author_query(query_param_author: str):
    books_to_return = []
    for book in BOOKS:
        if book.get('author').casefold() == query_param_author.casefold():
            books_to_return.append(book)

    return books_to_return

# http://127.0.0.1:8000/test/assignment/author%20two/
@app.get("/test/assignment/{path_param_author}/")
async def read_all_books_by_author_path(path_param_author: str):
    books_to_return = []
    for book in BOOKS:
        if book.get('author').casefold() == path_param_author.casefold():
            books_to_return.append(book)

    return books_to_return
"

-----------------------------------------------------------------------------------------------

#? Project 2
• Project two will still be focused on creating Book API Endpoints
• Continued Education includes: 
• GET, POST, PUT, DELETE Request Methods
• New Information will include: 
• Data Validation, Exception Handling, Status Codes, Swagger Configuration, Python Request Objects

#? Pydantic v1 vs Pydantic v2
FastAPI is now compatible with both Pydantic v1 and Pydantic v2.
Based on how new the version of FastAPI you are using, there could be small method name changes.

The three biggest are:
• .dict() function is now renamed to .model_dump()
• schema_extra function within a Config class is now renamed to json_schema_extra
• Optional variables need a =None example: id: Optional[int] = None

#! Setup Project - 2
1. Create a directory named "Project-2" and create a new python file named "books2.py"
2. Run the server using "fastapi dev .\Project-2\books2.py"
"
from fastapi import FastAPI

app = FastAPI()


class Book:
    id: int
    title: str
    author: str
    description: str
    rating: int

    def __init__(self, id, title, author, description, rating):
        self.id = id
        self.title = title
        self.author = author
        self.description = description
        self.rating = rating


BOOKS = [
    Book(1, 'Computer Science Pro', 'codingwithroby', 'A very nice book!', 5),
    Book(2, 'Be Fast with FastAPI', 'codingwithroby', 'A great book!', 5),
    Book(3, 'Master Endpoints', 'codingwithroby', 'A awesome book!', 5),
    Book(4, 'HP1', 'Author 1', 'Book Description', 2),
    Book(5, 'HP2', 'Author 2', 'Book Description', 3),
    Book(6, 'HP3', 'Author 3', 'Book Description', 1)
]


@app.get("/books")
async def read_all_books():
    return BOOKS
"

#! Post request before Validation
This is a basic post request that will create a new book but is not robust and will not validate the data.
"
@app.get("/create-book")
async def create_book(book_request=Body()):
    BOOKS.append(book_request)
"

#! Pydantics and Data Validation
• Python library that is used for data modeling, data parsing and has 
efficient error handling.
• Pydantics is commonly used as a resource for data validation and how to 
handle data coming to our FastAPI application.
• ** operator will pass the key/value from the request body to the Model class constructor.
"
from fastapi import Body, FastAPI
from pydantic import BaseModel

app = FastAPI()

class Book:
    id: int
    title: str
    author: str
    description: str
    rating: int

    def __init__(self, id, title, author, description, rating):
        self.id = id
        self.title = title
        self.author = author
        self.description = description
        self.rating = rating

class BookRequest(BaseModel):
    id: int
    title: str
    author: str
    description: str
    rating: int

BOOKS = [
    Book(1, 'Computer Science Pro', 'codingwithroby', 'A very nice book!', 5),
    Book(2, 'Be Fast with FastAPI', 'codingwithroby', 'A great book!', 5),
    Book(3, 'Master Endpoints', 'codingwithroby', 'A awesome book!', 5),
    Book(4, 'HP1', 'Author 1', 'Book Description', 2),
    Book(5, 'HP2', 'Author 2', 'Book Description', 3),
    Book(6, 'HP3', 'Author 3', 'Book Description', 1)
]


@app.get("/books")
async def read_all_books():
    return BOOKS

# @app.get("/create-book")
# async def create_book(book_request=Body()):
#     BOOKS.append(book_request)

@app.post("/create-book")
async def create_book(book_request: BookRequest):
    print(type(book_request)) #! <class 'books2.BookRequest'>
    print(book_request,"\n") #! id=0 title='string' author='string' description='string' rating=0 
    new_book = Book(**book_request.model_dump()) #! Converts the request to Book object
    print(type(new_book)) #! <class 'books2.Book'>
    print(new_book) #! <books2.Book object at 0x000001BE8A762840>
    BOOKS.append(new_book)
"

#! Data Validation with Pydantic -> Field Validation and id increments
"
from typing import Optional
from fastapi import Body, FastAPI
from pydantic import BaseModel, Field

app = FastAPI()


class Book:
    id: int
    title: str
    author: str
    description: str
    rating: int

    def __init__(self, id, title, author, description, rating):
        self.id = id
        self.title = title
        self.author = author
        self.description = description
        self.rating = rating

class BookRequest(BaseModel):
    id: Optional[int] = Field(description='ID is not needed on create', default=None)
    title: str = Field(min_length=3)
    author: str = Field(min_length=1)
    description: str = Field(min_length=1, max_length=100)
    rating: int = Field(gt=0, lt=6)

BOOKS = [
    Book(1, 'Computer Science Pro', 'codingwithroby', 'A very nice book!', 5),
    Book(2, 'Be Fast with FastAPI', 'codingwithroby', 'A great book!', 5),
    Book(3, 'Master Endpoints', 'codingwithroby', 'A awesome book!', 5),
    Book(4, 'HP1', 'Author 1', 'Book Description', 2),
    Book(5, 'HP2', 'Author 2', 'Book Description', 3),
    Book(6, 'HP3', 'Author 3', 'Book Description', 1)
]


@app.get("/books")
async def read_all_books():
    return BOOKS


@app.post("/create-book")
async def create_book(book_request: BookRequest): 
    new_book = Book(**book_request.model_dump()) #! Converts the request to Book object
    BOOKS.append(find_book_id(new_book))
    
def find_book_id(book: Book):
    #! If there are no books, the ID will be 1 and if there are few books present from before, the ID will be the last ID + 1
    book.id = 1 if len(BOOKS) == 0 else BOOKS[-1].id + 1
    
    # if len(BOOKS) > 0:
    #     book.id = BOOKS[-1].id + 1
    # else:
    #     book.id = 1
        
    return book
"

#! Pydantic Configuration
"
class BookRequest(BaseModel):
    id: Optional[int] = Field(description='ID is not needed on create', default=None)
    title: str = Field(min_length=3)
    author: str = Field(min_length=1)
    description: str = Field(min_length=1, max_length=100)
    rating: int = Field(gt=0, lt=6)
    
    model_config = {
        "json_schema_extra": {
            "example": {
                "title": "A new book",
                "author": "codingwithroby",
                "description": "A new description of a book",
                "rating": 5
            }
        }
    }
"

#! Fetch a single book
"
@app.get("/books/{book_id}")
async def read_book(book_id: int):
    for book in BOOKS:
        if book.id == book_id:
            return book
"

#! Fetch books by rating
"
@app.get("/books/")
async def read_book_by_rating(book_rating: int):
    books_to_return = []
    for book in BOOKS:
        if book.rating == book_rating:
            books_to_return.append(book)
            
    return books_to_return
"

#! Update Book with PUT Request
"
@app.put("/books/update_book")
async def update_book(book: BookRequest):
    book_changed = False
    for i in range(len(BOOKS)):
        if BOOKS[i].id == book.id:
            BOOKS[i] = book  
"

#! Delete Book with DELETE Request
"
@app.delete("/books/{book_id}")
async def delete_book(book_id: int):
    for i in range(len(BOOKS)):
        if BOOKS[i].id == book_id:
            BOOKS.pop(i)
            break
"

#? Assignment
Add a new field to Book and BookRequest called published_date: int (for example, published_date: int = 2012). So, this book as published on the year of 2012.
Enhance each Book to now have a published_date
Then create a new GET Request method to filter by published_date

"
from typing import Optional
from fastapi import Body, FastAPI
from pydantic import BaseModel, Field

app = FastAPI()

class Book:
    id: int
    title: str
    author: str
    description: str
    rating: int
    published_date: int

    def __init__(self, id, title, author, description, rating, published_date):
        self.id = id
        self.title = title
        self.author = author
        self.description = description
        self.rating = rating
        self.published_date = published_date

class BookRequest(BaseModel):
    id: Optional[int] = Field(description='ID is not needed on create', default=None)
    title: str = Field(min_length=3)
    author: str = Field(min_length=1)
    description: str = Field(min_length=1, max_length=100)
    rating: int = Field(gt=0, lt=6)
    published_date: int = Field(gt=2000, lt=2050)
    
    model_config = {
        "json_schema_extra": {
            "example": {
                "title": "A new book",
                "author": "codingwithroby",
                "description": "A new description of a book",
                "rating": 5,
                "published_date": 2024
            }
        }
    }

BOOKS = [
    Book(1, 'Computer Science Pro', 'codingwithroby', 'A very nice book!', 5, 2022),
    Book(2, 'Be Fast with FastAPI', 'codingwithroby', 'A great book!', 5, 2021),
    Book(3, 'Master Endpoints', 'codingwithroby', 'A awesome book!', 5, 2020),
    Book(4, 'HP1', 'Author 1', 'Book Description', 2, 2023),
    Book(5, 'HP2', 'Author 2', 'Book Description', 3, 2022),
    Book(6, 'HP3', 'Author 3', 'Book Description', 1, 2024)
]

@app.get("/books")
async def read_all_books():
    return BOOKS

@app.get("/books/{book_id}")
async def read_book(book_id: int):
    for book in BOOKS:
        if book.id == book_id:
            return book

@app.get("/books/")
async def read_book_by_rating(book_rating: int):
    books_to_return = []
    for book in BOOKS:
        if book.rating == book_rating:
            books_to_return.append(book)
            
    return books_to_return

@app.get("/books/publish/")
async def read_books_by_publish_date(published_date: int):
    books_to_return = []
    for book in BOOKS:
        if book.published_date == published_date:
            books_to_return.append(book)
    return books_to_return

@app.post("/create-book")
async def create_book(book_request: BookRequest): 
    new_book = Book(**book_request.model_dump()) #! Converts the request to Book object
    BOOKS.append(find_book_id(new_book))
    
def find_book_id(book: Book):
    #! If there are no books, the ID will be 1 and if there are few books present from before, the ID will be the last ID + 1
    book.id = 1 if len(BOOKS) == 0 else BOOKS[-1].id + 1        
    return book

@app.put("/books/update_book")
async def update_book(book: BookRequest):
    book_changed = False
    for i in range(len(BOOKS)):
        if BOOKS[i].id == book.id:
            BOOKS[i] = book  
            
@app.delete("/books/{book_id}")
async def delete_book(book_id: int):
    for i in range(len(BOOKS)):
        if BOOKS[i].id == book_id:
            BOOKS.pop(i)
            break
"

#! Data Validation Path Parameters
* used to validate and add constraints to the path parameter
* Example => Add Path(gt=0) to ID parameter in read_book() method

#! Data Validation Query Parameters
* used to validate and add constraints to the query parameter
* Example => Add Query(gt=0) to Rating parameter in read_book_by_rating() method

#! Status Codes
• An HTTP Status Code is used to help the Client (the user or system submitting data to the server) to understand what happened on the server side application.
• Status Codes are international standards on how a Client/Server should handle the result of a request.
• It allows everyone who sends a request to know if their submission was successful or not.

1xx => Success: Request Successfully complete
2xx => Information Response: Request Processing.
3xx => Redirection: Further action must be complete
4xx => Client Errors: An error was caused by the client.
5xx => Server Errors: An error occurred on the server.

#! HTTP Exceptions and status codes
"
from typing import Optional
from fastapi import Body, FastAPI, Path, Query, HTTPException
from pydantic import BaseModel, Field
from starlette import status

app = FastAPI()


class Book:
    id: int
    title: str
    author: str
    description: str
    rating: int
    published_date: int

    def __init__(self, id, title, author, description, rating, published_date):
        self.id = id
        self.title = title
        self.author = author
        self.description = description
        self.rating = rating
        self.published_date = published_date

class BookRequest(BaseModel):
    id: Optional[int] = Field(description='ID is not needed on create', default=None)
    title: str = Field(min_length=3)
    author: str = Field(min_length=1)
    description: str = Field(min_length=1, max_length=100)
    rating: int = Field(gt=0, lt=6)
    published_date: int = Field(gt=2000, lt=2050)
    
    model_config = {
        "json_schema_extra": {
            "example": {
                "title": "A new book",
                "author": "codingwithroby",
                "description": "A new description of a book",
                "rating": 5,
                "published_date": 2024
            }
        }
    }

BOOKS = [
    Book(1, 'Computer Science Pro', 'codingwithroby', 'A very nice book!', 5, 2022),
    Book(2, 'Be Fast with FastAPI', 'codingwithroby', 'A great book!', 5, 2021),
    Book(3, 'Master Endpoints', 'codingwithroby', 'A awesome book!', 5, 2020),
    Book(4, 'HP1', 'Author 1', 'Book Description', 2, 2023),
    Book(5, 'HP2', 'Author 2', 'Book Description', 3, 2022),
    Book(6, 'HP3', 'Author 3', 'Book Description', 1, 2024)
]


@app.get("/books", status_code=status.HTTP_200_OK)
async def read_all_books():
    return BOOKS


@app.get("/books/{book_id}", status_code=status.HTTP_200_OK)
async def read_book(book_id: int = Path(gt=0)):
    for book in BOOKS:
        if book.id == book_id:
            return book
    raise HTTPException(status_code=404, detail='Item not found')


@app.get("/books/", status_code=status.HTTP_200_OK)
async def read_book_by_rating(book_rating: int = Query(gt=0, lt=6)):
    books_to_return = []
    for book in BOOKS:
        if book.rating == book_rating:
            books_to_return.append(book)
    return books_to_return


@app.get("/books/publish/", status_code=status.HTTP_200_OK)
async def read_books_by_publish_date(published_date: int = Query(gt=1999, lt=2031)):
    books_to_return = []
    for book in BOOKS:
        if book.published_date == published_date:
            books_to_return.append(book)
    return books_to_return


@app.post("/create-book", status_code=status.HTTP_201_CREATED)
async def create_book(book_request: BookRequest): 
    new_book = Book(**book_request.model_dump()) #! Converts the request to Book object
    BOOKS.append(find_book_id(new_book))
    
def find_book_id(book: Book):
    #! If there are no books, the ID will be 1 and if there are few books present from before, the ID will be the last ID + 1
    book.id = 1 if len(BOOKS) == 0 else BOOKS[-1].id + 1        
    return book


@app.put("/books/update_book", status_code=status.HTTP_204_NO_CONTENT)
async def update_book(book: BookRequest):
    book_changed = False
    for i in range(len(BOOKS)):
        if BOOKS[i].id == book.id:
            BOOKS[i] = book
            book_changed = True
    if not book_changed:
        raise HTTPException(status_code=404, detail='Item not found')
            

@app.delete("/books/{book_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_book(book_id: int = Path(gt=0)):
    book_changed = False
    for i in range(len(BOOKS)):
        if BOOKS[i].id == book_id:
            BOOKS.pop(i)
            book_changed = True
            break
    if not book_changed:
        raise HTTPException(status_code=404, detail='Item not found')
"

-----------------------------------------------------------

#? Project - 3
• Project three we will be switching our focus to TODOS instead of BOOKS
• New Information will include: 
• Full SQL Database
• Authentication
• Authorization
• Hashing Passwords

#! MySQL Database Intro
• Organized collection of structured information of data, which is stored in a computer system.
• The data can be easily accessed
• The data can be modified
• The data can be controlled and organized
• Many databases use a structured query language (SQL) to modify and write data

• A database is a collection of data
• Since data, on its own, is just data. A database allows management of this data
• Databases are organized in how data can be retrieved, stored and modified
• There are many types of Database Management Systems -> MySQL, PostgreSQL, SQLite, MongoDB

#! Database Connection with ORM SQLAlchemy
* ORM is an object-relational mapper
* ORM is a library that allows us to interact with our database and perform CRUD and other database operations.
* Now run => pip install sqlalchemy 
* Now create a TodoApp directory and then a py file named database.py
"
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from sqlalchemy.ext.declarative import declarative_base

SQLALCHEMY_DATABASE_URL = 'sqlite:///./todos.db'

engine = create_engine(SQLALCHEMY_DATABASE_URL, connect_args={'check_same_thread': False})

SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

Base = declarative_base()
"

#! Database Tables (Models)
1. Inside the TodoApp directory, create a models.py file 
2. Since this is also a ORM based application, we have models similar to what we have in django
"
from database import Base
from sqlalchemy import Column, Integer, String, Boolean

class Todos(Base):
    __tablename__ = 'todos'

    id = Column(Integer, primary_key=True, index=True)
    title = Column(String)
    description = Column(String)
    priority = Column(Integer)
    complete = Column(Boolean, default=False)
"

#! Main (Create Database Connection for API)
1. Create a main.py file
"
from fastapi import FastAPI
import models
from database import engine

app = FastAPI()

models.Base.metadata.create_all(bind=engine)
"
2. Now run => fastapi dev .\Project-3\TodoApp\main.py
3. Your db will be created automatically

#! Get all todos from database
1. Go to main.py and write the code.
"
from typing import Annotated
from sqlalchemy.orm import Session
from fastapi import FastAPI, Depends
import models
from models import Todos
from database import engine, SessionLocal

app = FastAPI()

models.Base.metadata.create_all(bind=engine)

# This creates a connection with the db, then selects the data to the client and then closes the connection. This makes fastapi very fast and efficient.
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
        
# Depends is a dependency injection that allows us to inject the get_db function. Session is used to connect to the db using current session 
# Depends => A way to declare things that are required for a function/application to work by injecting the dependencies. 
db_dependency = Annotated[Session, Depends(get_db)]

@app.get("/")
async def read_all(db: db_dependency):
    return db.query(Todos).all()
"

#! Get todo by ID
"
@app.get("/todo/{todo_id}", status_code=status.HTTP_200_OK)
async def read_todo(db: db_dependency, todo_id: int = Path(gt=0)):
    todo_model = db.query(Todos).filter(Todos.id == todo_id).first()
    if todo_model is not None:
        return todo_model
    raise HTTPException(status_code=404, detail='Todo not found')
"

#! Post Request (Create and Save Todos)
"
class TodoRequest(BaseModel):
    title: str = Field(min_length=3)
    description: str = Field(min_length=3, max_length=100)
    priority: int = Field(gt=0, lt=6)
    complete: bool

@app.post("/todo", status_code=status.HTTP_201_CREATED)
async def create_todo(db: db_dependency,todo_request: TodoRequest):
    todo_model = Todos(**todo_request.model_dump())
    
    db.add(todo_model)
    db.commit()
"

#! Put Request (Update and Save Todos)
"
@app.put("/todo/{todo_id}", status_code=status.HTTP_204_NO_CONTENT)
async def update_todo(db: db_dependency, todo_request: TodoRequest, todo_id: int = Path(gt=0)):
    todo_model = db.query(Todos).filter(Todos.id == todo_id).first()
    
    if todo_model is None:
        raise HTTPException(status_code=404, detail='Todo not found')
    
    todo_model.title = todo_request.title
    todo_model.description = todo_request.description
    todo_model.priority = todo_request.priority
    todo_model.complete = todo_request.complete
    
    db.add(todo_model)
    db.commit()
"

#! Delete Request
"
@app.delete("/todo/{todo_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_todo(db: db_dependency, todo_id: int = Path(gt=0)):
    todo_model = db.query(Todos).filter(Todos.id == todo_id).first()
    
    if todo_model is None:
        raise HTTPException(status_code=404, detail='Todo not found')
    
    db.query(Todos).filter(Todos.id == todo_id).delete()
    
    db.commit()
"

#! Starting Authentication and Authorization
1. Create a auth.py file
"
from fastapi import FastAPI

app = FastAPI()

@app.get("/auth/")
async def get_user():
    return {'user': 'authenticated'}
"

#! Routers Scale Authentication File
1. Create a directory named routers.
2. Move the auth.py file to the routers directory
** auth.py
"
from fastapi import FastAPI, APIRouter

# app = FastAPI()

# @app.get("/auth/")
# async def get_user():
#     return {'user': 'authenticated'}

router = APIRouter()

@router.get("/auth/")
async def get_user():
    return {'user': 'authenticated'}
"
** main.py (Add these changes to main.py)
"
from routers import auth

app = FastAPI()

models.Base.metadata.create_all(bind=engine)

# This is similar to django routers, the endpoints of the main app will now also have the endpoints of the auth app
app.include_router(auth.router)
"
3. Now in swagger, we have routers of main.py along with auth.py

#! Router Scale Todos File
1. Create a new todos.py file inside the routers directory
2. Cut paste the code from main.py to todos.py and rename app to router and replace app = FastAPI() with router = APIRouter()
** todos.py
"
from typing import Annotated
from pydantic import BaseModel, Field
from sqlalchemy.orm import Session
from fastapi import APIRouter, FastAPI, Depends, HTTPException, Path
import models
from models import Todos
from database import engine, SessionLocal
from starlette import status
from routers import auth

router = APIRouter()

# models.Base.metadata.create_all(bind=engine)

# This is similar to django routers, the endpoints of the main app will now also have the endpoints of the auth app
# router.include_router(auth.router)

# This creates a connection with the db, then selects the data to the client and then closes the connection. This makes fastapi very fast and efficient.
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
        
# Depends is a dependency injection that allows us to inject the get_db function. Session is used to connect to the db using current session     
# Depends => A way to declare things that are required for a function/application to work by injecting the dependencies. 
db_dependency = Annotated[Session, Depends(get_db)]

class TodoRequest(BaseModel):
    title: str = Field(min_length=3)
    description: str = Field(min_length=3, max_length=100)
    priority: int = Field(gt=0, lt=6)
    complete: bool


@router.get("/", status_code=status.HTTP_200_OK)
async def read_all(db: db_dependency):
    return db.query(Todos).all()


@router.get("/todo/{todo_id}", status_code=status.HTTP_200_OK)
async def read_todo(db: db_dependency, todo_id: int = Path(gt=0)):
    todo_model = db.query(Todos).filter(Todos.id == todo_id).first()
    if todo_model is not None:
        return todo_model
    raise HTTPException(status_code=404, detail='Todo not found')


@router.post("/todo", status_code=status.HTTP_201_CREATED)
async def create_todo(db: db_dependency,todo_request: TodoRequest):
    todo_model = Todos(**todo_request.model_dump())
    
    db.add(todo_model)
    db.commit()
    

@router.put("/todo/{todo_id}", status_code=status.HTTP_204_NO_CONTENT)
async def update_todo(db: db_dependency, todo_request: TodoRequest, todo_id: int = Path(gt=0)):
    todo_model = db.query(Todos).filter(Todos.id == todo_id).first()
    
    if todo_model is None:
        raise HTTPException(status_code=404, detail='Todo not found')
    
    todo_model.title = todo_request.title
    todo_model.description = todo_request.description
    todo_model.priority = todo_request.priority
    todo_model.complete = todo_request.complete
    
    db.add(todo_model)
    db.commit()
    
    
@router.delete("/todo/{todo_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_todo(db: db_dependency, todo_id: int = Path(gt=0)):
    todo_model = db.query(Todos).filter(Todos.id == todo_id).first()
    
    if todo_model is None:
        raise HTTPException(status_code=404, detail='Todo not found')
    
    db.query(Todos).filter(Todos.id == todo_id).delete()
    
    db.commit()
"

** main.py (Add these changes to main.py)
"from fastapi import FastAPI
import models
from database import engine
from routers import auth, todos

app = FastAPI()

models.Base.metadata.create_all(bind=engine)

# This is similar to django routers, the endpoints of the main app will now also have the endpoints of the auth app
app.include_router(auth.router)
app.include_router(todos.router)
"

#! One to Many Relationship
User ---> Todo (One to Many) possible
but Todo ---> User (Many to One) not possible

User will have the primary_key (id) and Todo will have the foreign_key (id of the user)

#! WHAT IS A FOREIGN KEY?
* A foreign key (FK) is a column within a relational database table that provides a link between two separate tables.
* A foreign key references a primary key of another table
* Most relational databases need foreign keys to be able to link tables together to present data

#! Users table Creation
**models.py
"
from database import Base
from sqlalchemy import Column, Integer, String, Boolean, ForeignKey


class Users(Base):
    __tablename__ = 'users'

    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True)
    username = Column(String, unique=True)
    first_name = Column(String)
    last_name = Column(String)
    hashed_password = Column(String)
    is_active = Column(Boolean, default=True)
    role = Column(String)


class Todos(Base):
    __tablename__ = 'todos'

    id = Column(Integer, primary_key=True, index=True)
    title = Column(String)
    description = Column(String)
    priority = Column(Integer)
    complete = Column(Boolean, default=False)
    owner_id = Column(Integer, ForeignKey("users.id"))
"

#! Create First User
** auth.py
"
from fastapi import FastAPI, APIRouter
from pydantic import BaseModel
from models import Users

# app = FastAPI()

router = APIRouter()


class CreateUserRequest(BaseModel):
    username: str
    email: str
    first_name: str
    last_name: str
    password: str
    role: str


@router.post("/auth")
async def create_user(create_user_request: CreateUserRequest):
    create_user_model = Users(
        email=create_user_request.email,
        username=create_user_request.username,
        first_name=create_user_request.first_name,
        last_name=create_user_request.last_name,
        role=create_user_request.role,
        hashed_password=create_user_request.password,
        is_active=True,
    )

    return create_user_model
"

#! Hash User's Password
* pip install passlib
* pip install bcrypt==4.0.1
** auth.py
"
from fastapi import FastAPI, APIRouter
from pydantic import BaseModel
from models import Users
from passlib.context import CryptContext

# app = FastAPI()

router = APIRouter()

bcrypt_context = CryptContext(schemes=["bcrypt"], deprecated="auto")


class CreateUserRequest(BaseModel):
    username: str
    email: str
    first_name: str
    last_name: str
    password: str
    role: str


@router.post("/auth")
async def create_user(create_user_request: CreateUserRequest):
    create_user_model = Users(
        email=create_user_request.email,
        username=create_user_request.username,
        first_name=create_user_request.first_name,
        last_name=create_user_request.last_name,
        role=create_user_request.role,
        # hashed_password=create_user_request.password,
        hashed_password=bcrypt_context.hash(create_user_request.password),
    )

    return create_user_model
"

#! Save User Record to Database
** auth.py
"
from typing import Annotated
from fastapi import FastAPI, APIRouter, Depends
from pydantic import BaseModel
from models import Users
from passlib.context import CryptContext
from sqlalchemy.orm import Session
from database import SessionLocal
from starlette import status

router = APIRouter()

bcrypt_context = CryptContext(schemes=["bcrypt"], deprecated="auto")


class CreateUserRequest(BaseModel):
    username: str
    email: str
    first_name: str
    last_name: str
    password: str
    role: str
    
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
        
db_dependency = Annotated[Session, Depends(get_db)]


@router.post("/auth", status_code=status.HTTP_201_CREATED)
async def create_user(db: db_dependency,create_user_request: CreateUserRequest):
    create_user_model = Users(
        email=create_user_request.email,
        username=create_user_request.username,
        first_name=create_user_request.first_name,
        last_name=create_user_request.last_name,
        role=create_user_request.role,
        hashed_password=bcrypt_context.hash(create_user_request.password),
        is_active=True
    )

    db.add(create_user_model)
    db.commit()
"

#! Authenticate a User
* pip install python-multipart
* This package gives us the functionality of enter email and password for authentication
** auth.py
"
from typing import Annotated
from fastapi import FastAPI, APIRouter, Depends
from pydantic import BaseModel
from models import Users
from passlib.context import CryptContext
from sqlalchemy.orm import Session
from database import SessionLocal
from starlette import status
from fastapi.security import OAuth2PasswordRequestForm

router = APIRouter()

bcrypt_context = CryptContext(schemes=["bcrypt"], deprecated="auto")


class CreateUserRequest(BaseModel):
    username: str
    email: str
    first_name: str
    last_name: str
    password: str
    role: str
    
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
        
db_dependency = Annotated[Session, Depends(get_db)]

def authenticate_user(username: str, password: str, db):
    user = db.query(Users).filter(Users.username == username).first()
    if not user:
        return False
    if not bcrypt_context.verify(password, user.hashed_password):
        return False
    return user


@router.post("/auth", status_code=status.HTTP_201_CREATED)
async def create_user(db: db_dependency,create_user_request: CreateUserRequest):
    create_user_model = Users(
        email=create_user_request.email,
        username=create_user_request.username,
        first_name=create_user_request.first_name,
        last_name=create_user_request.last_name,
        role=create_user_request.role,
        hashed_password=bcrypt_context.hash(create_user_request.password),
        is_active=True
    )

    db.add(create_user_model)
    db.commit()

# form_data: This parameter will be automatically populated with data from the request form. FastAPI uses OAuth2PasswordRequestForm to know what kind of data to expect.
# OAuth2PasswordRequestForm: This is a class provided by FastAPI. It’s a special form class used to handle OAuth2 password grant flow. It expects data in a specific format, typically including fields like username and password.
@router.post("/token")
async def login_for_access_token(form_data: Annotated[OAuth2PasswordRequestForm, Depends()], db: db_dependency):
    
    user = authenticate_user(form_data.username, form_data.password, db)
    
    if not user:
        return "Failed Authentication"
    
    print("User's username: ", form_data.username, "  ", "User's password: ", form_data.password)
    return "Successful Authentication"
"

------------------------------------------------

#! WHAT IS A JSON WEB TOKEN?
* JSON Web Token is a self-contained way to securely transmit data and information between two parties using a JSON Object.
* JSON Web Tokens can be trusted because each JWT can be digitally signed, which in return allows the server to know if the JWT has been changed at all
* JWT should be used when dealing with authorization
* JWT is a great way for information to be exchanged between the server and client
* A JSON Web Token is created of three separate parts separated by dots ( . ) which include:
■ Header : (a)
■ Payload : (b)
■ Signature : (c)

Together they form the JWT : aaaaa.bbbbb.ccccc

#! a) JWT Header
A JWT header usually consist of two parts:
■ (alg) The algorithm for signing
■ “typ” The specific type of token
{
    "alg": "HS256",
    "typ": "JWT"
}
■ The JWT header is then encoded using Base64 to create the first part of the JWT (a)

#! b) JWT Payload
■ A JWT Payload consists of the data. 
{
    "sub": "1234567890",
    "name": "John Doe",
    "email": "XQn5z@example.com",
    "admin": true   
}
The Payloads data contains claims, and 
there are three different types of claims.
a) Registered
b) Public
c) Private
■ The JWT Payload is then encoded using Base64 to create the second part of the JWT (b)

#! c) JWT Signature
■ A JWT Signature is created by using the algorithm in the header to hash out the encoded header, encoded payload with a secret.
■ The secret can be anything, but is saved somewhere on the server that the client does not have access to.
■ The signature is the third and final part of a JWT (c)

----------------------------------------

#! Encode a JWT
* pip install "python-jose[cryptography]" => For encoding a JWT
* This package contains jwt functionality to encode a JWT and needs a secret_key and algorithm
** auth.py
"
from datetime import timedelta, timezone, datetime
from typing import Annotated
from fastapi import FastAPI, APIRouter, Depends
from pydantic import BaseModel
from models import Users
from passlib.context import CryptContext
from sqlalchemy.orm import Session
from database import SessionLocal
from starlette import status
from fastapi.security import OAuth2PasswordRequestForm
from jose import jwt

router = APIRouter()

SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM = "HS256"

bcrypt_context = CryptContext(schemes=["bcrypt"], deprecated="auto")


class CreateUserRequest(BaseModel):
    username: str
    email: str
    first_name: str
    last_name: str
    password: str
    role: str
    
    
class Token(BaseModel):
    access_token: str
    token_type: str
    
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
        
db_dependency = Annotated[Session, Depends(get_db)]

def authenticate_user(username: str, password: str, db):
    user = db.query(Users).filter(Users.username == username).first()
    if not user:
        return False
    if not bcrypt_context.verify(password, user.hashed_password):
        return False
    return user


def create_access_token(username: str, user_id: int, role: str, expires_delta: timedelta):
    encode = {'sub': username, 'id': user_id, 'role': role}
    expires = datetime.now(timezone.utc) + expires_delta
    encode.update({'exp': expires})
    return jwt.encode(encode, SECRET_KEY, algorithm=ALGORITHM)


@router.post("/auth", status_code=status.HTTP_201_CREATED)
async def create_user(db: db_dependency,create_user_request: CreateUserRequest):
    create_user_model = Users(
        email=create_user_request.email,
        username=create_user_request.username,
        first_name=create_user_request.first_name,
        last_name=create_user_request.last_name,
        role=create_user_request.role,
        hashed_password=bcrypt_context.hash(create_user_request.password),
        is_active=True
    )

    db.add(create_user_model)
    db.commit()

# form_data: This parameter will be automatically populated with data from the request form. FastAPI uses OAuth2PasswordRequestForm to know what kind of data to expect.
# OAuth2PasswordRequestForm: This is a class provided by FastAPI. It’s a special form class used to handle OAuth2 password grant flow. It expects data in a specific format, typically including fields like username and password.
# response_model: This parameter specifies the type of data that will be returned in the response.
@router.post("/token", response_model=Token)
async def login_for_access_token(form_data: Annotated[OAuth2PasswordRequestForm, Depends()], db: db_dependency):
    
    user = authenticate_user(form_data.username, form_data.password, db)
    
    if not user:
        print("Failed Authentication")
        return "Failed Authentication"
    
    token  = create_access_token(user.username, user.id, user.role, timedelta(minutes=20))
    
    print("Successful Authentication")
    print("User's username: ", form_data.username, "  ", "User's password: ", form_data.password)
    return {"access_token": token, "token_type": "bearer"}
"

#! Decode a JWT
* By decoding the JWT only we can authenticate and can get the username, user_id, and role of the user
"
async def get_current_user(token: Annotated[str, Depends(oauth2_bearer)]):
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username: str = payload.get('sub')
        user_id: int = payload.get('id')
        user_role: str = payload.get('role')
        if username is None or user_id is None:
            raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED,detail='Could not validate user.')
        
        return {'username': username, 'id': user_id, 'user_role': user_role}
    
    except JWTError:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED,detail='Could not validate user.')
"


#TODO => Go to jwt.io and paste this access key "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5cQ"

We get:- 

HEADER:ALGORITHM & TOKEN TYPE
{
  "alg": "HS256",
  "typ": "JWT"
}
PAYLOAD:DATA
{
  "sub": "1234567890",
  "name": "John Doe",
  "iat": 1516239022
}
VERIFY SIGNATURE
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  "*****" your-256-bit-secret
) secret base64 encoded